# Research: Release Scripts & Version Management

**Feature**: 033-release-scripts  
**Date**: 2026-01-29  
**Purpose**: Technical research and decision rationale for version management and release automation

## Overview

This document captures research findings and technical decisions for implementing version management, release branching, and automated binary builds for frozenDB.

## Research Areas

### 1. Version File Generation in Go

**Decision**: Generate `cmd/frozendb/version.go` with a package-level constant

**Rationale**:
- Simple and idiomatic Go approach - version is a compile-time constant
- No runtime file I/O required for version command
- Version is embedded in binary at compile time
- Follows standard Go practices (e.g., similar to how Go itself embeds version info)
- Compatible with existing cmd/frozendb package structure

**Implementation Approach**:
```go
// version.go - generated by scripts/bump-version.sh
package main

const Version = "v0.1.0"
```

**Alternatives Considered**:
1. **Build-time ldflags**: `go build -ldflags "-X main.Version=v0.1.0"`
   - Rejected: Requires remembering to pass flags every build, easy to forget
   - Rejected: Not visible in source code, harder to verify current version
2. **Runtime VERSION file read**: Read from external file at runtime
   - Rejected: Requires distributing VERSION file with binary
   - Rejected: Adds runtime I/O and error handling complexity
   - Rejected: File could be missing or modified after build

### 2. Version Tracking in Go Projects

**Decision**: Use generated `cmd/frozendb/version.go` file and git tags for version management

**Rationale**:
- Go modules track project versions via git tags (e.g., v0.1.0), not in go.mod
- The go.mod file only contains: module path, Go version requirement, and dependencies
- Version constant in version.go provides runtime access for CLI version command
- Git tags are the canonical source for Go module versioning
- This follows standard Go project conventions

**Implementation Approach**:
```go
// version.go - generated by scripts/bump-version.sh
package main

const Version = "v0.1.0"
```

**Alternatives Considered**:
1. **Store version in go.mod as comment**: 
   - Rejected: Non-standard, go.mod doesn't store project version
   - Rejected: Git tags are the Go-standard way to version modules
2. **Build-time ldflags**: `go build -ldflags "-X main.Version=v0.1.0"`
   - Rejected: Requires remembering to pass flags every build, easy to forget
   - Rejected: Not visible in source code, harder to verify current version

### 3. Script Language for Version Bump

**Decision**: Bash script for Unix-like systems (Linux, macOS)

**Rationale**:
- Bash is standard on Unix-like systems (Linux, macOS) where all Go development for this project occurs
- GitHub Actions runners have Bash available by default
- Maintainers work on Unix-like systems
- No Windows support required (out of scope)

**Implementation Approach**:
- Create `scripts/bump-version.sh` with full functionality
- Accept version as argument: `./scripts/bump-version.sh v0.1.0`
- Perform validation, git operations, and file generation
- Exit with clear error messages on any failure

**Alternatives Considered**:
1. **Go-based version bump tool**: Write bump tool in Go
   - Rejected: Adds complexity of building/distributing the tool
   - Rejected: Shell script is simpler for this straightforward task
2. **Make target only**: `make bump-version VERSION=v0.1.0`
   - Rejected: Still needs a script underneath to do the work
   - Accepted as addition: Can add Makefile target that calls the script

### 4. Semantic Version Validation

**Decision**: Use regex validation in bump-version script

**Pattern**: `^v[0-9]+\.[0-9]+\.[0-9]+(-[a-zA-Z0-9.-]+)?$`

**Rationale**:
- Validates semantic versioning format (vMAJOR.MINOR.PATCH)
- Supports pre-release tags (e.g., v1.0.0-rc1, v1.0.0-beta.2)
- Prevents invalid version strings from entering the codebase
- Standard regex is portable and well-understood

**Examples**:
- Valid: v0.1.0, v1.2.3, v2.0.0-rc1, v1.0.0-beta.2
- Invalid: 0.1.0 (missing 'v'), v1.2 (missing patch), v1.2.3.4 (too many parts)

### 5. Git Branch Naming Convention

**Decision**: Use `release/vX.Y.Z` pattern for release branches

**Rationale**:
- Clear namespace separation (release/ prefix)
- Version is immediately visible in branch name
- Consistent with common Git branching strategies (Git Flow, GitHub Flow)
- Easy to list all release branches: `git branch --list 'release/*'`

**Implementation**:
```bash
git checkout -b "release/$VERSION"
```

**Alternatives Considered**:
1. **Simple version branches**: `v0.1.0` (no prefix)
   - Rejected: Mixes with tags, less organized
2. **Dated branches**: `release/2026-01-29-v0.1.0`
   - Rejected: Redundant (Git history provides dates)

### 6. GitHub Actions Release Workflow Trigger

**Decision**: Trigger on GitHub release publication

**Trigger Configuration**:
```yaml
on:
  release:
    types: [published]
```

**Rationale**:
- Cleanly separates version bumping (PR flow) from building/distribution
- Allows maintainer to review and prepare release notes before triggering builds
- GitHub releases provide UI for managing releases and attaching artifacts
- Standard pattern for open source projects

**Alternatives Considered**:
1. **Trigger on tag push**: Build when tags are pushed
   - Rejected: Less control - tags might be pushed before release is ready
   - Rejected: No built-in place to attach artifacts (would need separate step)
2. **Trigger on main branch push**: Build on every merge to main
   - Rejected: Would build for every commit, not just releases
   - Rejected: No version tagging mechanism

### 7. Cross-Platform Binary Builds

**Decision**: Use Go's built-in cross-compilation with GOOS and GOARCH

**Build Matrix**:
```yaml
strategy:
  matrix:
    include:
      - os: darwin
        arch: amd64
      - os: darwin
        arch: arm64
      - os: linux
        arch: amd64
      - os: linux
        arch: arm64
```

**Build Command**:
```bash
GOOS=${{ matrix.os }} GOARCH=${{ matrix.arch }} go build -o dist/frozendb-${{ matrix.os }}-${{ matrix.arch }} ./cmd/frozendb
```

**Rationale**:
- Go's cross-compilation is reliable and requires no additional tools
- Can build all platforms from single runner (Linux)
- No need for platform-specific runners or build agents
- Faster and simpler than separate platform builds

**Alternatives Considered**:
1. **Platform-specific runners**: Build on macOS for darwin, Linux for linux
   - Rejected: Slower (needs multiple runners), more complex workflow
   - Rejected: macOS runners are more expensive in CI minutes
2. **Docker-based builds**: Build in containers
   - Rejected: Unnecessary complexity for Go cross-compilation

### 8. Binary Artifact Naming

**Decision**: `frozendb-{os}-{arch}` format

**Examples**:
- frozendb-darwin-amd64
- frozendb-darwin-arm64
- frozendb-linux-amd64
- frozendb-linux-arm64

**Rationale**:
- Clear indication of platform and architecture
- Follows common convention for multi-platform tools
- Easy to automate download (users can construct URL)
- Sorts naturally in file listings

**Alternatives Considered**:
1. **Include version in name**: `frozendb-v0.1.0-darwin-amd64`
   - Rejected: Redundant (release already has version)
   - Rejected: Makes download URLs more complex
2. **Platform-specific extensions**: `frozendb-darwin.bin`, `frozendb-linux.elf`
   - Rejected: Non-standard, confusing for users

### 9. CLI Version Command Integration

**Decision**: Add as subcommand, also support --version flag

**Implementation Pattern**:
```go
func main() {
    if len(os.Args) >= 2 && (os.Args[1] == "version" || os.Args[1] == "--version") {
        handleVersion()
    }
    // ... existing command routing
}

func handleVersion() {
    fmt.Printf("frozendb %s\n", Version)
    os.Exit(0)
}
```

**Rationale**:
- Follows CLI conventions (subcommand and flag both work)
- Consistent with existing command structure in cmd/frozendb/main.go
- Simple implementation with no external dependencies
- Exit code 0 indicates success

**Display Format**: `frozendb v0.1.0`
- Clear, concise
- Includes program name for context
- Version format matches release tags

### 10. Uncommitted Changes Handling

**Decision**: Check for uncommitted changes and warn, but allow override

**Implementation**:
```bash
if ! git diff-index --quiet HEAD --; then
    echo "Warning: You have uncommitted changes"
    echo "Press Ctrl+C to cancel, or Enter to continue"
    read
fi
```

**Rationale**:
- Prevents accidental version bumps with dirty working directory
- User can override if intentional (e.g., stacked changes)
- Follows principle of making the right thing easy but not blocking power users

**Alternatives Considered**:
1. **Hard error on dirty working directory**: Refuse to proceed
   - Rejected: Too restrictive, blocks legitimate workflows
2. **Auto-stash changes**: Stash, bump version, pop stash
   - Rejected: Too magical, could confuse users about state

### 11. Script Error Handling

**Decision**: Exit immediately on any error with `set -e`, provide clear error messages

**Pattern**:
```bash
set -e  # Exit on any error

# Before each operation, explain what's happening
echo "Creating release branch: release/$VERSION"
git checkout -b "release/$VERSION" || {
    echo "Error: Failed to create branch. Does it already exist?"
    exit 1
}
```

**Rationale**:
- Fail fast prevents cascading errors
- Clear messages help users diagnose and fix issues
- Script doesn't leave repository in inconsistent state
- Follows best practices for shell scripting

## Summary of Technical Decisions

| Component | Decision | Primary Rationale |
|-----------|----------|-------------------|
| Version constant | Generated version.go file | Simple, compile-time embedding, no runtime overhead |
| go.mod updates | `go mod edit -version` | Standard tool, atomic, validates format |
| Script language | Bash (primary) | Standard, available in CI, simple for task |
| Version format | Semantic versioning with v prefix | Standard, validates with regex |
| Branch naming | release/vX.Y.Z | Clear namespace, common pattern |
| Release trigger | GitHub release published | Clean separation, UI for management |
| Cross-compilation | GOOS/GOARCH | Built-in, reliable, fast |
| Binary naming | frozendb-{os}-{arch} | Clear, follows conventions |
| Version command | Subcommand + --version flag | Standard CLI patterns |
| Error handling | Fail fast with clear messages | Prevents cascading errors |

## Dependencies and Integration Notes

### Existing Codebase Integration
- **cmd/frozendb/main.go**: Add version command handler alongside existing commands (create, begin, commit, etc.)
- **Makefile**: Can optionally add `bump-version` target that calls script
- **.github/workflows/ci.yml**: Existing CI workflow unchanged, new release.yml is independent

### External Dependencies
- None required for core functionality
- GitHub Actions uses standard actions only:
  - actions/checkout@v4
  - actions/setup-go@v4
  - actions/upload-artifact@v4 (or similar for release assets)

### Testing Approach
- **Script testing**: Spec tests in scripts_spec_test/ verify script behavior
  - Create temporary git repo, run script, verify outcomes
- **CLI testing**: Spec tests in cmd/frozendb/main_spec_test.go verify version command
  - Build binary with known version, execute, verify output
- **Workflow testing**: GitHub Actions workflows are manually tested (t.Skip() as specified)
  - Create test release, verify builds complete and artifacts attach
